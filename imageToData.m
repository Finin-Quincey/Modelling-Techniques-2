%% Script to convert an image to a set of data points
% Deals with axes, scaling, value interpolation and text automatically
% Should in theory work for any graph in any image format MATLAB can read

% Prompts the user for the filename of the image to convert
filename = inputdlg('Enter filename for image (with extension):');
filename = filename{1}; % We need a string, not a cell array!

img = imread(filename);
dimensions = size(img);

% Colours for image masking
axisColour = uint8([0; 0; 0]); % Black
dataColour = uint8([255; 0; 0]); % Red

% Maybe get the user to click a point to sample the colour
% imshow(img, 'Border', 'tight');
% [x, y, button] = ginput(1);
% dataColour = uint8(img(int8(x), int8(y), :));

% Axis limits
% Would be good to either try and read these using ocr, or have the user enter them
xmin = 0;
xmax = 2000;
ymin = 0;
ymax = 2000;

% Optical character recognition
textData = ocr(img); % Can't call this 'text' because that is a function!

%% Locates the axes

% Isolates only the black pixels
imgbw = mask(img, axisColour, 30);

% Removes the text
for n = 1:length(textData.CharacterBoundingBoxes)
    corners = textData.CharacterBoundingBoxes(n, :);
    imgbw(corners(2):corners(2)+corners(4), corners(1):corners(1)+corners(3)) = 0;
end

%% Locates the longest vertical black line
currentLongest = 0;
% All coords are (y, x) for now
topRight = [0, 0];
origin = [0, 0];

for x = 1:dimensions(2)
    if sum(imgbw(:, x)) > currentLongest % Found a column with more black
        currentLongest = sum(imgbw(:, x)); % Store the new largest amount of black
        % Locate the endpoints
        topRight(2) = find(imgbw(:, x), 1, 'first'); % first because y is upside-down
        origin(1) = x;
    end
end

%% Locates the longest horizontal black line
currentLongest = 0;
% All coords are (y, x) for now
xAxisEnd = [0, 0];

for y = 1:dimensions(1)
    if sum(imgbw(y, :)) > currentLongest % Found a row with more black
        currentLongest = sum(imgbw(y, :)); % Store the new largest amount of black
        topRight(1) = find(imgbw(y, :), 1, 'last'); % Locate the endpoint
        origin(2) = y;
    end
end

%% Locates the data

% Dimensions of the area within the axes
plotDimensions = [abs(origin(1) - topRight(1)), abs(origin(2) - topRight(2))];

% Crops the image to the area within the axes (y is upside-down)
imgred = img(topRight(2):origin(2), origin(1):topRight(1), :);

% Isolates only the red pixels
imgred = mask(imgred, dataColour, 240); % 50 works well for the png, 240 is best for the jpg

pixelData = zeros(plotDimensions(1), 1);
% Finds the average height (in pixels) of the (red) data plot
for x = 1:plotDimensions(1)
    pixelData(x) = mean(find(imgred(:, x)));
end

%% Scales the values and sets NaN values to zero
xdata = (1:length(pixelData)) * ((xmax-xmin)/length(pixelData));
% plotDimensions(2) - pixelData inverts the values
ydata = (plotDimensions(2) - pixelData) * ((ymax-ymin)/plotDimensions(2));
% Replaces NaNs with zeros (is there a non-loop way of doing this?)
for x = 1:length(ydata)
    if isnan(ydata(x))
        ydata(x) = 0;
    end
end

%% Displays the result
plot(xdata, ydata);
hold on;
grid on;
xlim([xmin, xmax]);
ylim([ymin, ymax]);

%% Attempts to guess the titles
% Finds capitalised words
[a, b] = regexp(textData.Words, '[A-Z][a-zA-Z]*');

titles = {};

for n = 1:length(textData.Words)
    if ~isempty(a{n}) && ~isempty(b{n}) && a{n} == 1 && b{n} == length(textData.Words{n})
        titles = [titles, textData.Words(n)];
    end
end

if length(titles) > 1
    ylabel(titles{1});
    xlabel(titles{2});
end

%% Saves the data to a .mat file
save(filename(1 : find(filename == '.')-1), 'xdata', 'ydata');
% Clears all the variables generated by this script
%clear;

% Debug
%plot(origin(2), origin(1), 'xg');
%plot(yAxisTop(2), yAxisTop(1), 'xr');
%plot(xAxisEnd(2), xAxisEnd(1), 'xb');
%plot(pixelData);
%imshow(imgred);